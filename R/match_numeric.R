#' Matches groups by using numeric variables
#'
#' Matches groups by using numeric variables
#'
#' @param df data frame of numeric inputs. First column has group names, 1 line per group.
#' @param n size of the test group, and matching control group.
#' @return Outputs a list of test groups with matching control groups, 1 to 1 match.
#' @export



##----PART #1---------------------------------------------------------

# CREATE A RANKED LIST OF MATCHES BASED ON DISTANCE.

# Libraries loaded in BUILD_METRICS.R script
#require(reshape2)
#require(tidyverse)
#require(random)


match_numeric <- function ( df, n = 10 , test_list = NULL ) {

    # Prep for Distance: Convert column #1 to rownames and scale the dataset

    rownames(df) <- df[,1]
    df_scaled <- scale(df[,-1])

    #---- Build the Distant Matrix----
    DF_DIST <- dist(df_scaled , method = "euclidian")

    # Convert to Matrix
    DF_RANK_BASE <- as.matrix(DF_DIST)

    # Keep the full matrix for addressing duplicates: Force NA to diagonal
    diag(DF_RANK_BASE) <- NA

    #----Produce list of one to one distance Metric----
    DF_RANK_BASE_1 <- reshape2::melt(DF_RANK_BASE)
    names(DF_RANK_BASE_1) <- c("CONTROL","TEST","DIST_Q")

    DF_DIST_FINAL <- DF_RANK_BASE_1 %>% na.omit() %>%
      dplyr::arrange(TEST,DIST_Q,CONTROL)


    ##----PART #2----------------------------------------------------------

    # RANDOMLY SELECT THE LIST/DF OF THE TEST AND CONTROL GROUPS

    # Select random number for seed from random.org

    #rand_num <- random::randomNumbers(n = 1, min = 1, max = 1000000000, 1)
    #set.seed( rand_num ) # Number Generated by Random.org
    set.seed(17)
    if( is.null(test_list)) {
      DF_TEST <- df %>% dplyr::sample_n(size = n) # Need to include a InputSelector, sample size of test
    } else {
      DF_TEST <- as.data.frame(test_list$TEST)
    }
    # Test and Control List

    DF_DIST_REDUCED <- DF_DIST_FINAL %>% dplyr::filter(!CONTROL %in% (DF_TEST[,1])) %>%
      dplyr::filter(TEST %in% (DF_TEST[,1]))

    CONTROL_STR_LIST <- DF_DIST_REDUCED %>%
      dplyr::group_by(TEST) %>%
      dplyr::mutate(DIST_RANK = min_rank(DIST_Q)) %>%
      dplyr::filter(DIST_RANK <= 1) %>%
      dplyr::select(-DIST_RANK) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(GROUP = row_number())

    # Create list of Dupes
    DUPES_LIST <- CONTROL_STR_LIST %>% dplyr::group_by(CONTROL) %>%
      dplyr::summarise(control_cnt = n()) %>%
      dplyr::filter(control_cnt > 1)

    # Run While loop over the list of duplicates, until no more dupes remain
    i = 0

    while (nrow(DUPES_LIST) > 0) {
      # Count the number of iterations
      i = i + 1
      print(sprintf("The %sth de-duping iteration started", i))
      # rank the duplicate control stores and keep the minimum rank

      rank_dupes <- DUPES_LIST %>%
        dplyr::inner_join(CONTROL_STR_LIST) %>%
        dplyr::group_by(CONTROL) %>%
        dplyr::mutate(rank = dplyr::min_rank(DIST_Q)) %>%
        dplyr::filter(rank > 1)

      # Remove the duplicate from remaining distance list

      DF_DIST_FINAL_TEMP <- DF_DIST_REDUCED %>% dplyr::anti_join(rank_dupes, by = "CONTROL")

      # Remove the duplicate data from CONTROL_STR_LIST distance list

      CONTROL_STR_LIST_TEMP <-CONTROL_STR_LIST %>% dplyr::left_join(rank_dupes)

      CONTROL_STR_LIST_TEMP <- CONTROL_STR_LIST_TEMP %>%
        dplyr::mutate(CONTROL = dplyr::if_else(is.na(rank) == TRUE, CONTROL, NULL),
                      DIST_Q = dplyr::if_else(is.na(rank) == TRUE, DIST_Q,NULL))

      # select new minimum from the remaining list

      TEST_DUPES_TEMP <- CONTROL_STR_LIST_TEMP %>% dplyr::filter(is.na(DIST_Q)) %>% select(TEST)
      CONT_DUPES_TEMP <- CONTROL_STR_LIST_TEMP %>% dplyr::filter(!is.na(CONTROL)) %>% select(CONTROL)

      DIST_REMAINING <- DF_DIST_FINAL_TEMP %>% dplyr::inner_join(TEST_DUPES_TEMP, by = 'TEST') %>%
        dplyr::anti_join(CONT_DUPES_TEMP, by = 'CONTROL') %>%
        dplyr::group_by(TEST) %>%
        dplyr::arrange(TEST, DIST_Q) %>%
        dplyr::mutate(rank = min_rank(DIST_Q)) %>%
        dplyr::filter(rank == 1)

      # Add new control to test stores with missing controls stores

      CONTROL_STR_LIST <- CONTROL_STR_LIST_TEMP %>% dplyr::left_join(DIST_REMAINING, by = 'TEST') %>%
        dplyr::mutate( CONTROL = coalesce(CONTROL.x, CONTROL.y),
                DIST_Q  = coalesce(DIST_Q.x, DIST_Q.y)) %>%
        dplyr::select(CONTROL, TEST, DIST_Q, GROUP)

      # re-move all test and control stores from the current dist df
      DF_DIST_FINAL <- DF_DIST_FINAL_TEMP %>% dplyr::anti_join(CONTROL_STR_LIST, by = "CONTROL")

      # re-build the Dupes_list

      DUPES_LIST <- CONTROL_STR_LIST %>% dplyr::group_by(CONTROL) %>%
        dplyr::summarise(control_cnt = n()) %>%
        dplyr::filter(control_cnt > 1)

      # ends when DUPES_LIST is nrow() = 0
      print(sprintf("The %sth de-duping iteration complete.", i))

    }

    # Add series of test to ensure there are no duplicates in the data set below.
    # CONTROL_GROUP <- CONTROL_STR_LIST %>% dplyr::select(CONTROL) %>% dplyr::arrange(CONTROL)
    # TEST_GROUP <- CONTROL_STR_LIST %>% dplyr::select(TEST) %>% dplyr::arrange(TEST)
    #
    #
    #
    # CONTROL_DUPES_TEST <- nrow(CONTROL_STR_LIST %>%
    #                              dplyr::select(CONTROL) %>%
    #                              dplyr::group_by(CONTROL) %>%
    #                              dplyr::mutate(n = n()) %>%
    #                              dplyr::filter(n > 1))
    # TEST_DUPES_TEST <- nrow(CONTROL_STR_LIST %>%
    #                              dplyr::select(TEST) %>%
    #                              dplyr::group_by(TEST) %>%
    #                              dplyr::mutate(n = n()) %>%
    #                              dplyr::filter(n > 1))
    # if( CONTROL_DUPES_TEST == 0 ) {print("No duplicates in the control group.")}
    #   else { print('Duplicates found in the control group, dupes test failed.')}
    # if( TEST_DUPES_TEST == 0 ) {print("No duplicates in the test group")}
    #   else { print('Duplicates found in the test group, dupes test failed.')}
    #


    # Output list of Test and Controls
    return(CONTROL_STR_LIST)
      # assign( CONTROL_STR_LIST, paste0("Randomized Selection_seed_",rand_num), envir = .GlobalEnv #)
  }
